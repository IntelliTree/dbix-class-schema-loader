- General
  - High Priority
    - clean out RT queue
    - introspect views and make proper ResultSource::View classes with defining SQL
    - encode loader options in Schema.pm
    - introspect on_update/on_delete/is_deferrable
    - preserve_case mode for remaining backends
  - Low Priority
    - support multiple/all schemas, instead of just one
    - support pk/uk/fk info on views, possibly (materialized views?)
    - remove deprecated ResultSetManager stuff, rewrite using current features
    - Refactor RelBuilder so that it doesn't require a live mostly-built
      DBIx::Class::Schema, so that other modules (SQLT) can use it easier.  And
      then when/if we get there, break it out as a seperate distribution with a
      new name.
    - support for user-defined-types as Schema deploy hooks
    - finish data_type tests for all DBs (DB2 and Informix left)
    - generate a schema accessor which stores which SQLT type it was loaded from
    - add a settable 'on-behalf-of' version tag (for catalyst model)
    - inject a table2moniker function into the schema
    - support coderef for relationship_attrs
    - common tests for table/column comments
    - optimize queries
    - remove extra select for _filter_tables
    - option to promote non-nullable unique constraints to PK (prefer int
      columns when more than one) (RT#51696)
    - figure out how to represent Informix 'DATETIME YEAR TO FRACTION(5)' in a
      way that SQLT will like
    - support domains (aka custom data types) as a Schema deploy hook
    - add hashref form of generate_pod to control which POD is generated
    - add hashref form of components to control which components are added to
      which classes
    - add common tests for preserve_case option
    - check rel accessors for method conflicts
    - add an option to add extra code to Result classes
    - redo in-memory schema as an @INC coderef rather than temp files
    - add option to filter out views

- Relationships
   - Re-scan relations/tables after initial relation setup to find
     ->many_to_many() relations to be set up
   - While scanning for many-to-many, scan for implied rels as well (if
     foo->belongs_to('bar') and baz->belongs_to('bar'), does that impliy
     foo->might_have('baz') and the reverse?)

- Backends
  - SQLite
    - table/column comments
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
  - MySQL
    - table/column comments
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
    - domains?
  - Pg
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
    - preserve_case mode
    - domains
  - DB2
    - data_type tests
    - table/column comments
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
    - preserve_case mode
    - domains
  - Oracle
    - table/column comments
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
    - preserve_case mode
    - domains
  - Sybase ASE
    - table/column comments
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
    - domains
  - MSSQL
    - table/column comments
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
    - computed column support
    - domains
    - Optimization
      - use one query for whole table instead of query-per-column in _columns_info_for
      - use placeholders when available
  - SQLAnywhere
    - table/column comments
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
    - domains
  - Firebird
    - table/column comments
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
    - domains
  - Informix
    - data_type tests
    - preserve_case mode
    - table/column comments
    - introspect on_update/on_delete/is_deferrable
    - introspect view SQL
    - domains
